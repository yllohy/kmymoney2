<chapter id="rel-mgmt">
<title>Release Management</title>
<para>
At certain stages, the development team releases a version of &app;. The
following chapters explain the steps that are performed during this process.
</para>

<sect1 id="create-new-source-version">
<title>Creating a new source version</title>
<para>
The process of releasing a new version is to build a source tar-ball archive, verify
that &app; can be build from it and upload it to the SourceForge File Release System.
This chapter explains the steps of making sure that the version numbers are set
correctly, creating the source tar-ball, tagging the repository etc.

<note>
<para>
The steps explained apply for both the development branches as well as the
release branches. For convenience, the examples are based on the
development branch.
</para>
</note>
</para>

<orderedlist>
<listitem>
<para>
Visit all subdirectories that contain a shared library and check whether the code/interface of the
shared library has been changed since the last release. Modify the LIBVERSION setting in each
Makefile.am according to the following recipe, where
the LIBVERSION setting controls the libtool versioning system for shared
libraries. It is constructed out of the triplet CURRENT:REVISION:AGE.
</para>

<para>
  <orderedlist>
    <listitem><para>
      If the library source code has changed at all since the last
      release, then increment REVISION (`C:R:A' becomes `C:r+1:A').
    </para></listitem>

    <listitem><para>
      If any interfaces have been added, removed, or changed since the
      last update, increment CURRENT, and set REVISION to 0.
    </para></listitem>

    <listitem><para>
      If any interfaces have been added since the last public release,
      then increment AGE.
    </para></listitem>

    <listitem><para>
      If any interfaces have been removed since the last public release,
      then set AGE to 0.
    </para></listitem>
  </orderedlist>
</para>
<para>
<caution>
Make sure to modify the numbers in coordination with changes on the release- and development branch.
It could well be, that the REVISION must be incremented more than 1 if it has been changed on the other branch as well.
</caution>
</para>
</listitem>


<listitem>
<para>
Make sure that the project version is set correct to the
version to be created (e.g. 0.5.6) by opening the Help/About dialog box. The correct version number is determined
by the following rules (see also <link linkend="version-mgmt">Version Management</link> for more details.
</para>

<para>
<note>
Two types of versions can be created at this time: a <emphasis>follow-up</emphasis> release or a <emphasis>fresh stable</emphasis>
release. The follow-up release is based on a previous release with the same major and minor release number. The fresh stable
release starts a new major and minor release number pair. In the latter case, the major and minor release numbers on the
development branch in CVS are also adjusted. More details below.
</note>
</para>

<para>
  <orderedlist>
    <listitem><para>
    For follow-up releases increase the micro-release-number by one since the last unstable/stable release.    
    </para></listitem>
    <listitem><para>
    For a fresh stable release, increase the minor release number and set the micro-release number to 0.
    </para></listitem>
  </orderedlist>
</para>

<para>

If this is not the case, change the version in the file configure.in.in.
Afterwards, run the following commands:

<screen>
<prompt>thb: ~&gt; </prompt><userinput>make -f Makefile.dist</userinput>
<prompt>thb: ~&gt; </prompt><userinput>./configure <emphasis>&lt;any-options-you-need&gt;</emphasis></userinput>
<prompt>thb: ~&gt; </prompt><userinput>make</userinput>
</screen>
 
This will regenerate all files of the application and rebuild everything automatically.
</para>
</listitem>

<listitem>
<para>
Update the text source file for translations. This is done by running the command:

<screen>
<prompt>thb: ~&gt; </prompt><userinput>make package-messages</userinput>
</screen>
 
</para>
</listitem>

<listitem>
<para>
Run the command
 
<screen>
<prompt>thb: ~&gt; </prompt><userinput>make distcheck</userinput>
</screen>
 
This will do the following things automatically and stop on any error:
</para>

<para>
<orderedlist>
<listitem><para>create a source tar-ball in tgz form</para></listitem>
<listitem><para>unpack this source tar-ball in a seperate directory</para></listitem>
<listitem><para>run configure on the unpacked source tar-ball</para></listitem>
<listitem><para>compile and link the configured package</para></listitem>
<listitem><para>compile and link all testcases</para></listitem>
<listitem><para>installs the compiled program in a temp directory</para></listitem>
<listitem><para>checks that all files are installed</para></listitem>
<listitem><para>uninstalls the package from the temp space</para></listitem>
<listitem><para>checks that no files are left behind</para></listitem>
</orderedlist>
</para>

<para>
Make sure that everything builds correct. If errors occur, correct them and
rerun <command>make distcheck</command>. Once everything is ok, a respective message, that the tar-ball is
ready for distribution is shown at the end of <command>make distcheck</command>.
</para>
</listitem>

<listitem>
<para>
Add a line with the text <screen>  * Released x.y.z</screen> to the ChangeLog file.
</para>
</listitem>

<listitem>
<para>
Checkin the changes you have made in the previous two steps to the CVS repository before you proceed with the next step.
</para>
</listitem>

<listitem>
<para>
Tag the version with the applicable tag (e.g. rel-0-5-6)
</para>
</listitem>

<listitem>
<para>
Optimize the size of the tar-ball by compressing it from GZIP to BZIP2 compression. This can be done with the following two commands:

<screen>
<prompt>thb: ~&gt; </prompt><userinput>gunzip <emphasis>name-of-tar-ball</emphasis>.tgz</userinput>
<prompt>thb: ~&gt; </prompt><userinput>bzip2 -9 <emphasis>name-of-tar-ball</emphasis>.tar</userinput>
</screen>
</para>
</listitem>

<listitem>
<para>
Create a release note which should give some short information about the changes since the last release.
<note>
In recent releases, I collected all entries from the ChangeLog file and removed the headers of each entry.
</note>
</para>
</listitem>

<listitem>
<para>
Upload the tar-ball (bz2-version) to ftp://anonymous:&lt;your-email-address&gt;@upload.sourceforge.net:incoming and
make sure to use the binary transfer mode. For GUI users: <emphasis>anonymous</emphasis> is the user-name and 
<emphasis>your-email-address</emphasis> is the password. Next pull the uploaded file into the &app; section
of the File Release System on SourceForge so that the file will be visible to everyone on the internet.
Announce the presence of the source tar-ball archive as described in
<link linkend="announce-new-version">Announce new version</link>.
</para>
</listitem>

<listitem>
<para>
Make sure that you increase the project version to the next version. This is derived as follows:
</para>

<para>
  <orderedlist>
    <listitem><para>
    After a follow-up releases increase the micro-release-number by one since the last unstable/stable release.
    E.g.: The release you currently work on is called 0.7.3 then set the release number to 0.7.4 here.
    </para></listitem>
    <listitem><para>
    After a fresh stable release, increase the minor release number and set the micro-release number to 0. E.g.:
    The release you currently work on is called 0.6 then set the release number to 0.7.0 here.
    </para></listitem>
  </orderedlist>
</para>

<para>
Make those changes in configure.in.in.
Afterwards, run the following commands:

<screen>
<prompt>thb: ~&gt; </prompt><userinput>make -f Makefile.dist</userinput>
<prompt>thb: ~&gt; </prompt><userinput>./configure <emphasis>&lt;any-options-you-need&gt;</emphasis></userinput>
<prompt>thb: ~&gt; </prompt><userinput>make</userinput>
</screen>
 
This will regenerate all files of the application and rebuild everything automatically.
</para>
</listitem>

<listitem>
<para>
Check in the changes to configure.in.in into the CVS repository.
</para>
</listitem>
</orderedlist>

<note>
<para>
The version number in the sandbox is <emphasis>always</emphasis> the
version number that is currently developed (we're a little ahead here).
</para>
</note>

</sect1>


<sect1 id="create-stable-procedure">
<title>Creating a new stable version</title>
<para>
At a certain time in the project's development cycle, the configuration
manager decides that a feature freeze is necessary to start a new stable
version. The exact dates when this will happen are announced on the
developers mailing list ahead of the event. When the time has come to
freeze the features, a branch will be created as described in this
section. From this time on, the stable release will only be changed to make
the current features of the software more stable. New features are not
introduced to the stable branch but can be developed on the main
branch (unstable) in parallel.

</para>

<para>
When the time has come to create a new stable branch, the following steps
have to be performed.

<orderedlist>
<listitem>
<para>
Run through all the steps explaind in <link linkend="create-stable-example">Creating a new version</link>.
The version number used in this description for the stable version is 0.4.  Follow the path 
for a fresh stable release.
</para>
</listitem>

<listitem><para>
Create a branch off of the tagged version. The branch name is build by appending
the word <emphasis>-branch</emphasis> to the major- and
minor-release number of the stable release version.

For our example, the branch tag for versions 0.4 is
<emphasis>rel-0-4-branch</emphasis>. 
A complete example with all &cvs; commands can be found
<link linkend="create-stable-example">in the appendix</link>.
</para></listitem>

<listitem>
<para>
From this moment on, the developers working on versions 0.4.x must make
sure, that they checkout or update their sandbox using the
tag <emphasis>rel-0-4-branch</emphasis>. This gives them the head revisions of
the files on the 0.4 branch. Omitting this tag information will leave
them on the main branch. The main branch is reserved for the unstable
versions. An example how to keep multiple branches on the same machine is
presented in the <link linkend="multiple-branches">appendix</link>,

<caution>
<para>
The developers really have to
take care from this point on which version they are modifying in their
sandbox. Besides that, it is the developers responsibility to make sure
that bug-fixes are also implemented on the main-branch if applicable.
</para>
</caution>

</para>

<para>
When fixes are applied to the branch, new versions can be created by
incrementing the micro-release thus rel-0-4-1, rel-0-4-2 are the next
tags on the release branch.
</para>

</listitem>
</orderedlist>

<note>
<para>
Since &cvs; does not allow periods inside a tag, we always replace periods
(.) with dashes (-) inside a tag.
</para>
</note>

<para>
The following diagram shows the above example on two specifc files. Each
node represented by an asterisk is labelled with it's revision number
enclosed in parenthesis. If a node has one or more labels attached, then
they are enclosed in brackets. Nodes may exist without a tag. Such
revisions never went into a release neither stable nor unstable but are
valid intermediate steps in the development of the file in question.
</para>

<example>
<title>Revisions on the head of a stable branch</title>
<para>
The first file is changed rather often between the version tags. All tags
are on different revisions of the file.
</para>

<screen>


     *     (1.12) [rel-0-3-8]
     |
     *     (1.13)
     |
     *     (1.14) [rel-0-4]
     |\__________________________
     |                           \
     |                            |
     *     (1.15)                 * (1.14.2.1)  [rel-0-4-1]
     |                            |
     *     (1.16) [rel-0-5-0]     * (1.14.2.2)  [rel-0-4-2]

   [HEAD]                  [rel-0-4-branch]


</screen>

<para>
The second file is not changed at all between the version
tags. Nevertheless, all tags are available even though now they are on
the same revision 1.2.
</para>

<screen>


     *     (1.2) [rel-0-3-8] [rel-0-4]
     |           [rel-0-4-1] [rel-0-4-2] [rel-0-5-0]
     |\__________________________
     |                           \
     |                            |

   [HEAD]                   [rel-0-4-branch]


</screen>

</example>


</para>
</sect1>




<sect1 id="announce-new-version">
<title>Announce a new version</title>
<para>
Once the file is visible on the internet, people need to be informed about the new
release. Besides that, the project maintains certain pages, where information about the
current release is kept. These pages need to be updated.
</para>

<sect2 id="announce-new-version-release-system">
<title>Announce new version via File Release System</title>
<para>
The SourceForge File Release System allows to send a short mail about the release of a package to registered
recipients. On the bottom of the page where the uploaded file is moved into the file space of &app; a checkbox
can be activated to send out such a mail. This method should only be used for a new source tar-ball release.
</para>
</sect2>

<sect2 id="update-web-sites">
<title>Update information about release on web-sites</title>
<para>
Certain web-sites exist that keep version information about &app;. They need to be updated.
<orderedlist>
<listitem><para>
The news system for &app; on SourceForge.net:  Create a news entry on https://sourceforge.net/projects/kmymoney2.
</para></listitem>

<listitem><para>
The &app; web-site at http://kmymoney2.sourceforge.net/:  Update all version info
for the stable and development releases and update the links to the source tar-balls.
</para></listitem>

<listitem><para>
The &app; web-site at http://www.kde-apps.arg/: Add the release notes and update the version and minimum requirements.
</para></listitem>

<listitem><para>
The &app; web-site at http://kmymoney2.sourceforge.net/: Update the links to the latest stable and development release.
If you created a fresh stable release, comment the development release entry.
</para></listitem>
</orderedlist>
</para>
</sect2>

<sect2 id="announce-new-version-mail">
<title>Announce new version on mailing lists</title>
<para>
Write a short mail and send it to the developer- and user-mailing list of the project, so that all subscribed
recipients are informed about the new release. Add links to the project web-site and the www.kde-apps.org page
of the project.
</para>
</sect2>

</sect1>






<sect1 id="create-new-bin-version">
<title>Creating a new binary/installable version</title>
<para>
Additionally, installable binary versions of &app; should be provided. Since the installable binary
files differ from distribution to distribution and the generation in general requires the
target platform, the &app; project relies on the help of people not directly involved in
the application development. We greatfully appreciate any help in this area.
</para>

<para>
Multiple formats exist: RPM, DEB, e-builds, PKG just to name a few. Since the distro I use (SuSE) relies on
RPMs, I explain the creation in more detail here. If you can provide similar information about other formats,
we are more than happy to include it in this document. We assume that you follow our licence terms for any
documentation you supply. Please send your docbook formatted files to the developer mailing list.
</para>


<sect2 id="rpm">
<title>Creating an RPM file</title>
<para>
One possibility to distribute the program is to use the Red-Hat Package
manager (RPM) format. In order to be able to create such a package for
&app;, you need to have a source tar-ball as described in <link
linkend="create-new-source-version">the previous chapter</link>.
</para>

<para>
The RPM system uses a directory structure which
for my system - a SuSE distribution - is located in /usr/src/packages. This
may be different on your system. The location can be configured in
/etc/rpmrc.
I will refer to this directory as the 'RPM base directory' in the remainder
of this document.
</para>

<para>
The RPM base directory has a set of subdirectories. They all serve a
specific purpose. For us, the directories SOURCES, SPECS, SRPMS and RPMS
are important. RPMS is further divided into directories for specific
CPU architectures (e.g. i386, i486, ppc, etc.). In the remainder of this
document, I will use the names of these directories without mentioning
the RPM base directory.
</para>
</sect2>

<sect2 id="rpm-tar-ball">
<title>Copying the tar-ball to the RPM structure</title>
<para>
The first thing that needs to be done is to copy the tar-ball to a defined
place where the RPM tool will look for it. For this purpose the SOURCES
directory is used. Move or copy your <link 
linkend="create-new-source-version">tar-ball</link> to this directory.
</para>
</sect2>

<sect2 id="rpm-test-building">
<title>Test building</title>
<para>
<!-- taken from RPM Howto (start) -->
   The first thing you'll probably want to do is get the source to build
   cleanly without using RPM. To do this, unpack the sources, and change
   the directory name to $NAME.orig. Then unpack the source again. Use
   this source to build from. Go into the source directory and follow the
   instructions to build it. If you have to edit things, you'll need a
   patch. Once you get it to build, clean the source directory. Make sure
   and remove any files that get made from a configure script. Then cd
   back out of the source directory to its parent. Then you'll do
   something like:

<screen>

  <prompt>thb:~&gt; </prompt><userinput>diff -uNr dirname.orig dirname &gt; ../SOURCES/dirname-distroname.patch</userinput>


</screen>

   This will create a patch for you that you can use in your spec file.
   Note that the "distro-name" that you see in the patch name is just an
   identifier. You might want to use something more descriptive like
   "MDK9" or "RPM8" to describe why you had to make a patch. It's also
   a good idea to look at the patch file you are creating before using it
   to make sure no binaries were included by accident.
<!-- taken from RPM Howto (end) -->
<note>
<para>
This section has been copied from the RPM-Howto and adapted where necessary
</para>
</note>
</para>
</sect2>

<sect2 id="rpm-specfile">
<title>Setting up the SPEC file</title>
<para>
The next step is to create an RPM SPEC file for the specific distribution.
The contents may vary between distribution and that is where your knowledge
is required. An example for an RPM SPEC file is contained in appendix ??.
It will work on SuSE 8.1 directly. More details on howto setup a SPEC file
including an explanation of the various sections, commands and options is
contained in the RPM-Howto. 
</para>
</sect2>

<sect2 id="rpm-build-package">
<title>Building the package</title>
<para>
Once you have the spec file it's time to try and build your package. The
usual way to do this is using the following command:


<screen>

  <prompt>thb:~&gt; </prompt><userinput>rpmbuild -ba kmymoney.spec</userinput>


</screen>

Once the command finishes successfully, you have a source RPM in SRPMS and
a binary RPM for your distribution in one of the subdirectories of RPMS.
<note>
<para>
More details about this process and a description on the available options
can be found in the RPM-Howto.
</para>
</note>
</para>
</sect2>

<sect2 id="rpm-test">
<title>Testing the package</title>
<para>
<!-- taken from RPM Howto (start) -->
   Once you have a source and binary rpm for your package, you need to
   test it. The easiest and best way is to use a totally different
   machine from the one you are building on to test. After all, you've
   just done a lot of make install's on your own machine, so it should be
   installed fairly well.
</para>

<para>
   You can do an rpm -e packagename on the package to test, but that can
   be deceiving because in building the package, you did a make install.
   If you left something out of your file list, it will not get
   uninstalled. You'll then reinstall the binary package and your system
   will be complete again, but your rpm still isn't. Make sure and keep
   in mind that just because you do a rpm -ba package, most people
   installing your package will just be doing the rpm -i package. Make
   sure you don't do anything in the build or install sections that will
   need to be done when the binaries are installed by themselves.
<!-- taken from RPM Howto (end) -->

<note>
<para>
This section has been copied from the RPM-Howto and adapted where necessary
</para>
</note>
</para>
</sect2>

<sect2 id="rpm-sign">
<title>Signing the package</title>
<para>
Once you are confident with the RPM package, it is a good idea to sign it
with your secret &GPG; key before you distribute it. Signing the package
allows any recipient of the package to verify that it has not been altered
by an unauthorized party.
</para>

<para>
 Signing will create a
separate file that contains the electronic signature for the RPM file.
In order to allow any
recipient to verify the signature, two things have to be kept in mind:

<itemizedlist>
<listitem>
   <para>Always distribute both files together</para>
</listitem>
<listitem>
   <para>
      Make your public key available on e.g.
      <ulink url="http://www.keyserver.net/">http://www.keyserver.net</ulink>.
   </para></listitem>
</itemizedlist>

The following example shows the command sequence necessary to create an
ASCII armored signature.
</para>

<para>
<screen>


  <prompt>thb:~&gt; </prompt><userinput>gpg -b -a kmymoney2-0.5.1-1.i386.rpm</userinput>
  You need a passphrase to unlock the secret key for
  user: "Thomas Baumgart &lt;thb@net-bembel.de&gt;"
  1024-bit DSA key, ID B75DD3BA, created 2001-06-23

  Enter passphrase: <userinput>I WON'T TELL YOU MY PASSPHRASE ;-)</userinput>
  <prompt>thb:~&gt; </prompt><userinput></userinput>


</screen>
</para>

<para>
Once you have entered the correct passphrase the signature file will be
created under the name kmymoney2-0.5.1-1.i386.rpm.asc. As an example, I
include it here. <command>THIS IS NOT THE REAL SIGNATURE, EVEN IF IT LOOKS LIKE
IT</command>. 
</para>

<para>
<screen>

   -----BEGIN PGP SIGNATURE-----
   Version: GnuPG v1.0.7 (GNU/Linux)

   iD8DBQA+E1DInFnbQLdd07oRAmFQAKDV0I9nzxGEIh1Mx/tzoZ4J3Iyt6gCfTXl1
   LrISXXgD6xELWZlO+NsWbLw=
   =qJIP
   -----END PGP SIGNATURE-----

</screen>
</para>

<para>
These two files, the RPM and the signature,  should be distributed to
the public. The receiver of these
two files can now verify if the RPM file is the one you signed or has been
modified. Therefor, he needs your public key which he gets from one of the
public key servers (e.g. <ulink
url="http://www.keyserver.net/">http://www.keyserver.net</ulink>) into his
keyring. The verification is performed using &GPG; as the following example
shows:
</para>


<para>
<screen>


  <prompt>thb:~&gt; </prompt><userinput>gpg --verify kmymoney2-0.5.1-1.i386.rpm.asc</userinput>
  gpg: Signature made Wed 01 Jan 2003 09:16:37 PM CET using DSA key ID B75DD3BA
  gpg: Good signature from "Thomas Baumgart &lt;thb@net-bembel.de&gt;"
  <prompt>thb:~&gt; </prompt><userinput></userinput>


</screen>

<note>
<para>
Besides signing the RPM package, the SRPM (Source-RPM) package should be
signed as well.
</para>
</note>
</para>
</sect2>

</sect1>
</chapter>
